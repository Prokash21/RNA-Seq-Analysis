# Save the filtered data to a CSV file
write.csv(top_gene_names, file = "Top_gene_names_I_vs_mock_20.csv", row.names = FALSE)
# Create a vector of gene names in the same order as the top_hits
gene_names_ordered <- top_gene_names$gene_name
show(gene_names_ordered)
# Create a heatmap with row names replaced by gene names
heatmap_data <- assay(rld)[top_hits, ]
ordered_gene_ids <- rownames(heatmap_data)[order(rownames(heatmap_data))]
heatmap_data_ordered <- heatmap_data[ordered_gene_ids, ]
colnames(heatmap_data_ordered) <- custom_col_names
rownames(heatmap_data_ordered) <- gene_names_ordered
pheatmap(heatmap_data_ordered,
cluster_rows = FALSE,
show_rownames = TRUE,
cluster_cols = FALSE,
main = "Heatmap of rld for TOP 20 genes_names(I_vs_mock)" )
pheatmap(heatmap_data_ordered,
main= "Heatmap of rld for TOP 20 cluster(I_vs_mock)")
df <- as.data.frame(colData(dds)[,c("Cell_type", "Treatment")])
pheatmap(heatmap_data_ordered,cluster_rows = FALSE,show_rownames = TRUE,cluster_cols = FALSE)
#        annotation_col = df)
# Calculate Z-scores for the top 20 genes
cal_z_score <- function(x) {
(x - mean(x)) / sd(x)
}
zscore_all <- t(apply(normalize_counts, 1, cal_z_score))
zscore_subset <- zscore_all[top_hits, ]
# Create a heatmap of Z-scores with gene names as row names
rownames(zscore_subset) <- gene_names_ordered
colnames(zscore_subset) <- custom_col_names
pheatmap(zscore_subset,
main = "Heatmap of Z scores with gene names")
#heatmap of Z scores . we will use the top 20 genes
cal_z_score1 <- function(x){(x-mean(x)) / sd(x)}
zscore_all1 <- t(apply(normalize_counts, 1, cal_z_score1))
zscore_subset1 <- zscore_all1 [top_hits,]
pheatmap(zscore_subset1,
main = "Heatmap of Z scores")
View(rld)
#Regularized log transformation
rld <- rlog(dds,blind = FALSE)
View(rld)
rld$sizeFactor
X->rld$sizeFactor
X-> rld$sizeFactor
View(rld)
x -> as.data.frame(rld)
x -> assay(rld)
x -> assay(rld)[top_hits, ]
x<-as.data.frame(assay(rld)[top_hits, ])
View(x)
write.csv(x,file = "Top_20_Heatmap.csv")
library(DESeq2)
library(pheatmap)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(ggrepel)
#set the working directory
setwd("D:/DWCT/DEG/GSE219036_6_june/keratinocyte/vs_mock/vs_mock/IIb_vs_mock")
#load the count data
count_data <- read.csv("count_keratinocyte.csv", header=TRUE,row.names = 1)
count_data1 <- read.csv("count_keratinocyte.csv")
#qnew <- count_data[count_data$GSM6765254 == 35.28909350,]
colnames(count_data)
head(count_data)
#load the sample info
sample_info1 <- read.csv("meta_keratinocyte.csv")
sample_info <- read.csv("meta_keratinocyte.csv", header = TRUE,row.names = 1)
colData1 <- read.csv("meta_keratinocyte.csv", header = T, sep = '\t',
stringsAsFactors = TRUE)
colData <- read.csv("meta_keratinocyte.csv", header = TRUE,row.names = 1)
colnames(sample_info)
head(sample_info)
#set factor levels
sample_info$Treatment <- factor(sample_info$Treatment)
sample_info$Cell_type <- factor(sample_info$Cell_type)
# Convert non-integer values to integers in count data
count_data <- round(count_data)
head(count_data)
# Create a new count data object
new_count_data <- as.matrix(count_data)
head(new_count_data)
unique(sample_info$Treatment)
unique(sample_info$Cell_type)
# Generate the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = new_count_data, colData = sample_info, design = ~ Treatment)
# Perform DESeq2 analysis
dds <- DESeq(dds)
head(dds)
#set the factor level
dds$Treatment <- factor(dds$Treatment, levels = c ("mock","MPXV clade I infected", "MPXV clade IIb infected", "MPXV clade IIa infected"))
#filter the genes
keep <- rowSums(counts(dds)) >= 5
dds <- dds[keep,]
dds
#set the referene for the treatment factor
dds$Treatment <- relevel(dds$Treatment , ref = "mock")
dds$Treatment
#perform the statistical tests to identify differentialy expressed genes
dds <- DESeq(dds)
head(dds)
#save the normalized counts
normalize_counts <- counts(dds,normalized=TRUE)
head(normalize_counts)
dim(normalize_counts)
write.csv(normalize_counts,"normalized_counts_keratinocyte_IIb_vs_mock.csv")
#####################################
# Boxplot
#boxplot(count_data, outline = FALSE,
#   main="Boxplot of count data")
# Log2 transformation for count data
count_matrix <- counts(dds) + 1  # Adding 1 to avoid log(0)
log2_count_matrix <- log2(count_matrix)
boxplot(log2_count_matrix, outline = FALSE, main = "Boxplot of Log2-transformed Count Data",
xlab = "Sample Name",
ylab = "Log2-transformed Counts")
# Log2 transformation for normalized count data
normalized_counts <- counts(dds, normalized = TRUE)
log2_normalized_counts <- log2(normalized_counts + 1)  # Adding 1 to avoid log(0)
#colnames(log2_normalized_counts) <- custom_col_names
boxplot(log2_normalized_counts, outline = FALSE,
main = "Boxplot of Log2-transformed Normalized Count Data",
xlab = "Sample Name",
ylab = "Log2-transformed Counts")
#####################################
#BiocManager::install("EDASeq")
library(EDASeq)
par(mfrow = c(2, 1))
plotRLE(DESeq2::counts(dds, normalized = FALSE),
outline=FALSE, ylim=c(-2, 2),
col = as.numeric(sample_info$Treatment),
main = 'Raw counts',
xlab = "Sample Name",
ylab = "LFC")
plotRLE(DESeq2::counts(dds, normalized = TRUE),
outline=FALSE, ylim=c(-2, 2),
col = as.numeric(sample_info$Treatment),
main = 'Normalized Counts (DESeq2)',
xlab = "Sample Name",
ylab = "LFC")
##############################################
boxplot(count_data)
# Boxplot for count data
par(mfrow = c(1, 2))  # Create a 1x2 grid for side-by-side plots
boxplot(counts(dds), main = "Count Data", xlab = "Treatment", ylab = "Counts", col = "lightblue")
# Boxplot for normalized count data
boxplot(normalize_counts, main = "Normalized Count Data", xlab = "Treatment", ylab = "Normalized Counts", col = "lightgreen")
# Reset the layout
par(mfrow = c(1, 1))
####################################
par(mar=c(8,5,2,2))
boxplot(log10(assays(dds)[["cooks"]]), range=0, las=2,
main = "box plot for cooks")
boxplot(normalized_counts, range=0, las=2,
main = "box plot for cooks")
#RESULT
#for MPXV clade IIa infected
deseq_results_IIa <- results(dds, contrast=c("Treatment", "MPXV clade IIb infected", "mock"))
deseq_results_IIa <- as.data.frame(deseq_results_IIa)
head(deseq_results_IIa)
deseq_results_IIa_0.05 <- results(dds,contrast=c("Treatment", "MPXV clade IIb infected", "mock"), alpha = 0.05)
deseq_results_IIa_0.05 <- as.data.frame(deseq_results_IIa_0.05)
head(deseq_results_IIa_0.05)
# create histogram plot of p-values
hist(deseq_results_IIa_0.05$padj, breaks=seq(0, 1, length = 21), col = "grey", border = "white",
xlab = "", ylab = "", main = "Frequencies of padj-values")
deseq_results <- deseq_results_IIa_0.05
summary(deseq_results)
#baseMean         log2FoldChange         lfcSE              stat               pvalue            padj
#Min.   :    0.309   Min.   :-6.02053   Min.   :0.04332   Min.   :-22.29339   Min.   :0.0000   Min.   :0.000
#1st Qu.:    2.056   1st Qu.:-0.42893   1st Qu.:0.36149   1st Qu.: -0.57022   1st Qu.:0.2559   1st Qu.:0.292
#Median :   10.394   Median : 0.03209   Median :0.69160   Median :  0.02914   Median :0.5316   Median :0.673
#Mean   :   57.049   Mean   : 0.06721   Mean   :1.22547   Mean   :  0.05383   Mean   :0.5144   Mean   :0.584
#3rd Qu.:   35.265   3rd Qu.: 0.46585   3rd Qu.:1.69303   3rd Qu.:  0.68085   3rd Qu.:0.7862   3rd Qu.:0.884
#ax.   :24141.945   Max.   :20.81238   Max.   :4.40736   Max.   : 25.96353   Max.   :1.0000   Max.   :1.000
#NA's   :1        NA's   :10203
#Researchers are often interested in minimizing the number of false discoveries.
#Change DEseq object to R object(dataframe)
deseq_results <- as.data.frame(deseq_results)
class(deseq_results)
head(deseq_results)
#Extract the most differentially expressed genes due to the treatment.
#Select genes with a significant change in gene expression (adjusted p-value below 0.05)
#And log2fold change <1 and >1
#Step 1: filter based on p adjusted value
filtered <- deseq_results %>% filter(deseq_results$padj < 0.05)
head(filtered)
dim(filtered)
#Step 2: filter based on fold changes. here we will use a threshold of 1
filtered <- filtered %>% filter(abs(filtered$log2FoldChange)>1)
dim(deseq_results)
dim(filtered)
#make queries
#Save the deseg result. We will save the both the original data(res) and the filtered one(hits)
write.csv(deseq_results,"deseq_result_keratinocyte_IIb_vs_mock.csv")
write.csv(filtered,"filtered_keratinocyte_IIb_vs_mock.csv")
#visualization
##########################
#Computational genomics with R
#MA plot
DESeq2::plotMA(object = dds, ylim = c(-5, 5))
#P-value distribution
#P-value distribution genes before adjusting for multiple testing.
ggplot(data = as.data.frame(deseq_results), aes(x = pvalue)) +
geom_histogram(bins = 100)
#PCA plot
#Relative Log Expression (RLE) plot
#BiocManager::install("EDASeq")
#install.packages("EDASeq")
##########################
#dispersion plot
plotDispEsts(dds)
#PCA
#pca stands for principal component analysis.
#it is a dimensionality reduction technique and in gene expression analysis, 139 #it can be used to explain the variance in gene expression datasets.
#to generate the pca plot we will first perform a variance stabilizing transformation.
#we will use the vst function in deseq.
#after that we use the transformed values to plot the PCA
#variance transformed values to generate a pca plot
library("vsn")
#Variance stabilizing transformation
vsd <- vst (dds,blind = FALSE)
#Regularized log transformation
rld <- rlog(dds,blind = FALSE)
# this gives log2(n + 1)
ntd <- normTransform(dds)
head(assay(vsd),3)
head(assay(rld),3)
head(assay(ntd),3)
meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))
meanSdPlot(assay(ntd))
#use transformed values to generate a pcs plot
plotPCA(vsd,intgroup=c("Cell_type", "Treatment"))
plotPCA(rld,intgroup=c("Cell_type", "Treatment"))
plotPCA(ntd,intgroup=c("Cell_type", "Treatment"))
# PCA plot
rld <- vst(dds)
DESeq2::plotPCA(rld, ntop = 500, intgroup = 'Treatment') +
ylim(-25, 25) + theme_bw()
#QQ-plot of raw p-values from DE analysis
###################################################### Heatmaps ############################################################
#R Package: pheatmap
#Heatmap of sample-to-sample distance matrix (with clustering) based on the normalized counts.
#generate the distance matrix
sampledists <- dist (t (assay(vsd)))
sampleDistMatrix <- as.matrix(sampledists)
# Define custom row and column names (replace these with your desired names)
#sample_info1 <- read.csv("meta_keratinocyte.csv")
custom_row_names <- paste(sample_info1$Sample.Name, sample_info1$Treatment, sep = "_")
custom_col_names <- paste(sample_info1$Sample.Name, sample_info1$Treatment, sep = "_")
rownames(sampleDistMatrix) <- custom_row_names
colnames(sampleDistMatrix) <- custom_col_names
#set color scheme
colors <- colorRampPalette(rev(brewer.pal(9, "Purples")))(255)#Blues,Purples
#generate the heatmap_111111
pheatmap(sampleDistMatrix,clustering_distance_rows=sampledists,
clustering_distance_cols = sampledists, col=colors,
main = "Heatmap of sample-to-sample distance matrix for IIb_vs_mock")
#Heatmap of log transformed normalized counts. We will use the top 20 genes.
df <- as.data.frame(colData(dds)[,c("Treatment","Cell_type")])
#top 20 genes
top_hits <- deseq_results_IIa_0.05[order(deseq_results_IIa_0.05$padj),][1:20,]
top_hits <-row.names(top_hits)
top_hits
write.csv(top_hits,"top_hits_IIb_vs_mock_20.csv")
class(top_hits)
# Order the values in the top_hits character vector
top_hits <- top_hits[order(top_hits)]
# Create the heatmap using the ordered top_hits
pheatmap(assay(rld)[top_hits, ],
cluster_rows = FALSE,
show_rownames = TRUE,
cluster_cols = FALSE,
fontsize_row = 8,
annotation_col = df,
main = "Heatmap of rld for TOP 20 genes_ids(IIb_vs_mock)")
pheatmap(assay(rld)[top_hits, ],
cluster_rows = TRUE,
show_rownames = TRUE,
cluster_cols = TRUE,
fontsize_row = 8,
annotation_col = df,
main = "Heatmap of rld for TOP 20 genes_ids(IIb_vs_mock)")
x<-as.data.frame(assay(rld)[top_hits, ])
write.csv(x,file = "Top_20_Heatmap.csv")
library(DESeq2)
library(pheatmap)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(ggrepel)
#set the working directory
setwd("D:/DWCT/DEG/GSE219036_6_june/keratinocyte/vs_mock/vs_mock/IIa_vs_mock")
#load the count data
count_data <- read.csv("count_keratinocyte.csv", header=TRUE,row.names = 1)
colnames(count_data)
head(count_data)
#load the sample info
sample_info1 <- read.csv("meta_keratinocyte.csv")
sample_info <- read.csv("meta_keratinocyte.csv", header = TRUE,row.names = 1)
colData1 <- read.csv("meta_keratinocyte.csv", header = T, sep = '\t',
stringsAsFactors = TRUE)
colData <- read.csv("meta_keratinocyte.csv", header = TRUE,row.names = 1)
colnames(sample_info)
head(sample_info)
#set factor levels
sample_info$Treatment <- factor(sample_info$Treatment)
sample_info$Cell_type <- factor(sample_info$Cell_type)
# Convert non-integer values to integers in count data
count_data <- round(count_data)
head(count_data)
# Create a new count data object
new_count_data <- as.matrix(count_data)
head(new_count_data)
unique(sample_info$Treatment)
unique(sample_info$Cell_type)
# Generate the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = new_count_data, colData = sample_info, design = ~ Treatment)
# Perform DESeq2 analysis
dds <- DESeq(dds)
head(dds)
#set the factor level
dds$Treatment <- factor(dds$Treatment, levels = c ("mock","MPXV clade I infected", "MPXV clade IIb infected", "MPXV clade IIa infected"))
#filter the genes
keep <- rowSums(counts(dds)) >= 5
dds <- dds[keep,]
dds
#set the referene for the treatment factor
dds$Treatment <- relevel(dds$Treatment , ref = "mock")
dds$Treatment
#perform the statistical tests to identify differentialy expressed genes
dds <- DESeq(dds)
head(dds)
#save the normalized counts
normalize_counts <- counts(dds,normalized=TRUE)
head(normalize_counts)
dim(normalize_counts)
write.csv(normalize_counts,"normalized_counts_keratinocyte_IIa_vs_mock.csv")
#####################################
# Boxplot
#boxplot(count_data, outline = FALSE,
#   main="Boxplot of count data")
# Log2 transformation for count data
count_matrix <- counts(dds) + 1  # Adding 1 to avoid log(0)
log2_count_matrix <- log2(count_matrix)
boxplot(log2_count_matrix, outline = FALSE, main = "Boxplot of Log2-transformed Count Data")
# Log2 transformation for normalized count data
normalized_counts <- counts(dds, normalized = TRUE)
log2_normalized_counts <- log2(normalized_counts + 1)  # Adding 1 to avoid log(0)
#colnames(log2_normalized_counts) <- custom_col_names
boxplot(log2_normalized_counts, outline = FALSE,
main = "Boxplot of Log2-transformed Normalized Count Data")
##################################################
#BiocManager::install("EDASeq")
library(EDASeq)
par(mfrow = c(2, 1))
plotRLE(DESeq2::counts(dds, normalized = FALSE),
outline=FALSE, ylim=c(-2, 2),
col = as.numeric(sample_info$Treatment),
main = 'Raw counts')
plotRLE(DESeq2::counts(dds, normalized = TRUE),
outline=FALSE, ylim=c(-2, 2),
col = as.numeric(sample_info$Treatment),
main = 'Normalized Counts (DESeq2)')
##############################################
boxplot(count_data)
# Boxplot for count data
par(mfrow = c(1, 2))  # Create a 1x2 grid for side-by-side plots
boxplot(counts(dds), main = "Count Data", xlab = "Treatment", ylab = "Counts", col = "lightblue")
# Boxplot for normalized count data
boxplot(normalize_counts, main = "Normalized Count Data", xlab = "Treatment", ylab = "Normalized Counts", col = "lightgreen")
# Reset the layout
par(mfrow = c(1, 1))
####################################
par(mar=c(8,5,2,2))
boxplot(log10(assays(dds)[["cooks"]]), range=0, las=2,
main = "box plot for cooks")
boxplot(normalized_counts, range=0, las=2,
main = "box plot for cooks")
#RESULT
#for MPXV clade IIa infected
deseq_results_IIa <- results(dds, contrast=c("Treatment", "MPXV clade IIa infected", "mock"))
deseq_results_IIa <- as.data.frame(deseq_results_IIa)
head(deseq_results_IIa)
deseq_results_IIa_0.05 <- results(dds,contrast=c("Treatment", "MPXV clade IIa infected", "mock"), alpha = 0.05)
deseq_results_IIa_0.05 <- as.data.frame(deseq_results_IIa_0.05)
head(deseq_results_IIa_0.05)
# create histogram plot of p-values
hist(deseq_results_IIa_0.05$padj, breaks=seq(0, 1, length = 21), col = "grey", border = "white",
xlab = "", ylab = "", main = "Frequencies of padj-values")
deseq_results <- deseq_results_IIa_0.05
summary(deseq_results)
#baseMean         log2FoldChange         lfcSE              stat               pvalue            padj
#Min.   :    0.309   Min.   :-6.02053   Min.   :0.04332   Min.   :-22.29339   Min.   :0.0000   Min.   :0.000
#1st Qu.:    2.056   1st Qu.:-0.42893   1st Qu.:0.36149   1st Qu.: -0.57022   1st Qu.:0.2559   1st Qu.:0.292
#Median :   10.394   Median : 0.03209   Median :0.69160   Median :  0.02914   Median :0.5316   Median :0.673
#Mean   :   57.049   Mean   : 0.06721   Mean   :1.22547   Mean   :  0.05383   Mean   :0.5144   Mean   :0.584
#3rd Qu.:   35.265   3rd Qu.: 0.46585   3rd Qu.:1.69303   3rd Qu.:  0.68085   3rd Qu.:0.7862   3rd Qu.:0.884
#ax.   :24141.945   Max.   :20.81238   Max.   :4.40736   Max.   : 25.96353   Max.   :1.0000   Max.   :1.000
#NA's   :1        NA's   :10203
#Researchers are often interested in minimizing the number of false discoveries.
#Change DEseq object to R object(dataframe)
deseq_results <- as.data.frame(deseq_results)
class(deseq_results)
head(deseq_results)
#Extract the most differentially expressed genes due to the treatment.
#Select genes with a significant change in gene expression (adjusted p-value below 0.05)
#And log2fold change <1 and >1
#Step 1: filter based on p adjusted value
filtered <- deseq_results %>% filter(deseq_results$padj < 0.05)
head(filtered)
dim(filtered)
#Step 2: filter based on fold changes. here we will use a threshold of 1
filtered <- filtered %>% filter(abs(filtered$log2FoldChange)>1)
dim(deseq_results)
dim(filtered)
#make queries
#Save the deseg result. We will save the both the original data(res) and the filtered one(hits)
write.csv(deseq_results,"deseq_result_keratinocyte_IIa_vs_mock.csv")
write.csv(filtered,"filtered_keratinocyte_IIa_vs_mock.csv")
#visualization
##########################
#Computational genomics with R
#MA plot
DESeq2::plotMA(object = dds, ylim = c(-5, 5))
#P-value distribution
#P-value distribution genes before adjusting for multiple testing.
ggplot(data = as.data.frame(deseq_results), aes(x = pvalue)) +
geom_histogram(bins = 100)
#PCA plot
#Relative Log Expression (RLE) plot
#BiocManager::install("EDASeq")
#install.packages("EDASeq")
##########################
#dispersion plot
plotDispEsts(dds)
#PCA
#pca stands for principal component analysis.
#it is a dimensionality reduction technique and in gene expression analysis, 139 #it can be used to explain the variance in gene expression datasets.
#to generate the pca plot we will first perform a variance stabilizing transformation.
#we will use the vst function in deseq.
#after that we use the transformed values to plot the PCA
#variance transformed values to generate a pca plot
library("vsn")
#Variance stabilizing transformation
vsd <- vst (dds,blind = FALSE)
#Regularized log transformation
rld <- rlog(dds,blind = FALSE)
# this gives log2(n + 1)
ntd <- normTransform(dds)
head(assay(vsd),3)
head(assay(rld),3)
head(assay(ntd),3)
meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))
meanSdPlot(assay(ntd))
#use transformed values to generate a pcs plot
plotPCA(vsd,intgroup=c("Cell_type", "Treatment"))
plotPCA(rld,intgroup=c("Cell_type", "Treatment"))
plotPCA(ntd,intgroup=c("Cell_type", "Treatment"))
# PCA plot
rld <- vst(dds)
DESeq2::plotPCA(rld, ntop = 500, intgroup = 'Treatment') +
ylim(-25, 25) + theme_bw()
#QQ-plot of raw p-values from DE analysis
###################################################### Heatmaps ############################################################
#R Package: pheatmap
#Heatmap of sample-to-sample distance matrix (with clustering) based on the normalized counts.
#generate the distance matrix
sampledists <- dist (t (assay(vsd)))
sampleDistMatrix <- as.matrix(sampledists)
# Define custom row and column names (replace these with your desired names)
#sample_info1 <- read.csv("meta_keratinocyte.csv")
custom_row_names <- paste(sample_info1$Sample.Name, sample_info1$Treatment, sep = "_")
custom_col_names <- paste(sample_info1$Sample.Name, sample_info1$Treatment, sep = "_")
rownames(sampleDistMatrix) <- custom_row_names
colnames(sampleDistMatrix) <- custom_col_names
#set color scheme
colors <- colorRampPalette(rev(brewer.pal(9, "Purples")))(255)#Blues,Purples
#generate the heatmap_111111
pheatmap(sampleDistMatrix,clustering_distance_rows=sampledists,
clustering_distance_cols = sampledists, col=colors,
main = "Heatmap of sample-to-sample distance matrix for IIa_vs_mock")
#Heatmap of log transformed normalized counts. We will use the top 20 genes.
df <- as.data.frame(colData(dds)[,c("Treatment","Cell_type")])
#top 20 genes
top_hits <- deseq_results_IIa_0.05[order(deseq_results_IIa_0.05$padj),][1:20,]
top_hits <-row.names(top_hits)
top_hits
write.csv(top_hits,"top_hits_IIa_vs_mock_20.csv")
class(top_hits)
# Order the values in the top_hits character vector
top_hits <- top_hits[order(top_hits)]
# Create the heatmap using the ordered top_hits
pheatmap(assay(rld)[top_hits, ],
cluster_rows = FALSE,
show_rownames = TRUE,
cluster_cols = FALSE,
fontsize_row = 8,
annotation_col = df,
main = "Heatmap of rld for TOP 20 genes_ids(IIa_vs_mock)")
pheatmap(assay(rld)[top_hits, ],
cluster_rows = TRUE,
show_rownames = TRUE,
cluster_cols = TRUE,
fontsize_row = 8,
annotation_col = df,
main = "Heatmap of rld for TOP 20 genes_ids(IIa_vs_mock)")
x<-as.data.frame(assay(rld)[top_hits, ])
write.csv(x,file = "Top_20_Heatmap.csv")
